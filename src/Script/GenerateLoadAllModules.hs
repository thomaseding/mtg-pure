{-# LANGUAGE BlockArguments #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE Unsafe #-}
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}

module Script.GenerateLoadAllModules (
  main,
) where

import safe Data.Functor ((<&>))
import safe Data.List (isSuffixOf, sort)
import System.Directory (doesDirectoryExist, listDirectory)
import safe System.FilePath (dropExtension, (</>))
import safe System.IO (IOMode (..), hFlush, hPutStrLn, withFile)
import System.Process (system)

--------------------------------------------------------------------------------

srcDir :: FilePath
srcDir = "."

--------------------------------------------------------------------------------

main :: IO ()
main = generateLoadAllModules

hsFileToModuleName :: FilePath -> String
hsFileToModuleName = map go . dropExtension
 where
  go = \case
    '\\' -> '.'
    '/' -> '.'
    c -> c

generateLoadAllModules :: IO ()
generateLoadAllModules = do
  allFiles <- listDirectoryRecursive srcDir
  let allHsFiles = filter (".hs" `isSuffixOf`) allFiles
  let modules = map (hsFileToModuleName . drop (length srcDir + 1)) allHsFiles
  let moduleLines =
        sort $
          modules <&> \case
            "LoadAllModules" -> "-- import LoadAllModules () -- can't include self"
            m -> "import " ++ m ++ " ()"
  let fileLines =
        [ "{-# LANGUAGE Unsafe #-}"
        , ""
        , "-- | XXX: This module is generated by `Script.GenerateLoadAllModules`."
        , "--"
        , "-- This module is used to load all modules in the project."
        , "-- Useful for checking that all modules compile."
        , "module LoadAllModules ("
        , "  ) where"
        , ""
        ]
          ++ moduleLines
  let pathLoadAllModules = srcDir </> "LoadAllModules.hs"
  withFile pathLoadAllModules WriteMode \h -> do
    hPutStrLn h $ unlines fileLines
    hFlush h -- needed?
  runFourmolu pathLoadAllModules

listDirectoryRecursive :: FilePath -> IO [FilePath]
listDirectoryRecursive dir = do
  allFiles <- listDirectory dir
  let allFiles' = map (dir </>) allFiles
  allFiles'' <- concat <$> mapM go allFiles'
  pure $ allFiles' ++ allFiles''
 where
  go file = do
    isDir <- doesDirectoryExist file
    if isDir
      then listDirectoryRecursive file
      else return []

runFourmolu :: FilePath -> IO ()
runFourmolu path = do
  let cmd = "fourmolu --mode inplace " ++ path
  _ <- system cmd
  pure ()
