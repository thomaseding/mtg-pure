-- XXX: Keep these LANGUAGE pragmas in this file for code generation scripts
{-# LANGUAGE BlockArguments #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE Unsafe #-}
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}

{-# HLINT ignore "Avoid lambda" #-}
{-# HLINT ignore "Use const" #-}
{-# HLINT ignore "Redundant multi-way if" #-}
{-# HLINT ignore "Use ++" #-}
{-# HLINT ignore "Use tuple-section" #-}
{-# HLINT ignore "Use if" #-}

module MtgPure.Model.Object.ToObjectN.CodeGen (
  main,
  mainCodeGenToObjectN,
) where

import safe Data.List (intercalate, sort, sortBy, subsequences, (\\))
import safe Data.Maybe (catMaybes)
import safe qualified Data.Set as Set
import safe qualified Data.Traversable as T
import safe MtgPure.Model.Object.OT (OT)
import safe System.FilePath (dropExtension)
import safe System.IO (IOMode (..), hFlush, hPutStrLn, withFile)
import System.Process (system)

--------------------------------------------------------------------------------

srcDir :: FilePath
srcDir = "."

--------------------------------------------------------------------------------

-- runhaskell MtgPure/Model/Object/ToObjectN/CodeGen.hs
main :: IO ()
main = mainCodeGenToObjectN

runFourmolu :: FilePath -> IO ()
runFourmolu path = do
  let cmd = "fourmolu --mode inplace " ++ path
  _ <- system cmd
  pure ()

mkInstancesHeader :: [String] -> String
mkInstancesHeader importPaths =
  unlines
    [ "{-# LANGUAGE Safe #-}"
    , ""
    , "-- This file is generated by MtgPure.Model.Object.ToObjectN.CodeGen"
    , "module MtgPure.Model.Object.ToObjectN.Instances () where"
    , ""
    ]
    ++ unlines (map (\x -> "import safe " ++ x ++ " ()") importPaths)

mkInstancesHeaderN :: Int -> String
mkInstancesHeaderN n =
  unlines
    [ "{-# LANGUAGE ConstraintKinds #-}"
    , "{-# LANGUAGE DataKinds #-}"
    , "{-# LANGUAGE FlexibleContexts #-}"
    , "{-# LANGUAGE FlexibleInstances #-}"
    , "{-# LANGUAGE GADTs #-}"
    , "{-# LANGUAGE MultiParamTypeClasses #-}"
    , "{-# LANGUAGE NoMonomorphismRestriction #-}"
    , "{-# LANGUAGE PolyKinds #-}"
    , "{-# LANGUAGE RankNTypes #-}"
    , "{-# LANGUAGE Safe #-}"
    , "{-# LANGUAGE ScopedTypeVariables #-}"
    , "{-# LANGUAGE TypeFamilyDependencies #-}"
    , "{-# OPTIONS_GHC -Wno-missing-signatures #-}"
    , "{-# OPTIONS_GHC -Wno-orphans #-}"
    , "{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}"
    , ""
    , "{-# HLINT ignore \"Avoid lambda\" #-}"
    , "{-# HLINT ignore \"Use const\" #-}"
    , "{-# HLINT ignore \"Redundant bracket\" #-}"
    , ""
    , "-- This file is generated by MtgPure.Model.Object.ToObjectN.CodeGen"
    , "module MtgPure.Model.Object.ToObjectN.Instances.ToObject_" ++ show n ++ " () where"
    , ""
    , "import safe Data.Inst (Inst" ++ show n ++ ")"
    , "import safe MtgPure.Model.Object.IsObjectType (IsObjectType)"
    , "import safe MtgPure.Model.Object.ObjectN (ObjectN (..))"
    , "import safe MtgPure.Model.Object.ToObjectN.Classes(ToObject" ++ show n ++ "'(..))"
    , ""
    ]

mkInstancesHeaderMN :: [Dependency] -> Int -> Int -> String
mkInstancesHeaderMN deps m n =
  unlines
    [ "{-# LANGUAGE ConstraintKinds #-}"
    , "{-# LANGUAGE DataKinds #-}"
    , "{-# LANGUAGE FlexibleContexts #-}"
    , "{-# LANGUAGE FlexibleInstances #-}"
    , "{-# LANGUAGE GADTs #-}"
    , "{-# LANGUAGE MultiParamTypeClasses #-}"
    , "{-# LANGUAGE NoMonomorphismRestriction #-}"
    , "{-# LANGUAGE PolyKinds #-}"
    , "{-# LANGUAGE RankNTypes #-}"
    , "{-# LANGUAGE Safe #-}"
    , "{-# LANGUAGE ScopedTypeVariables #-}"
    , "{-# LANGUAGE TypeFamilyDependencies #-}"
    , "{-# OPTIONS_GHC -Wno-missing-signatures #-}"
    , "{-# OPTIONS_GHC -Wno-orphans #-}"
    , "{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}"
    , ""
    , "{-# HLINT ignore \"Avoid lambda\" #-}"
    , "{-# HLINT ignore \"Use const\" #-}"
    , "{-# HLINT ignore \"Redundant bracket\" #-}"
    , ""
    , "-- This file is generated by MtgPure.Model.Object.ToObjectN.CodeGen"
    , "module MtgPure.Model.Object.ToObjectN.Instances.ToObject_" ++ show m ++ "_" ++ show n ++ " () where"
    , ""
    , "import safe Data.Inst (Inst" ++ show n ++ ")"
    , "import safe MtgPure.Model.Object.IsObjectType (IsObjectType)"
    , if
        | m == n -> ""
        | not (null deps) || m + 1 == n -> "import safe MtgPure.Model.Object.ObjectN (ObjectN (..))"
        | otherwise -> ""
    , "import safe MtgPure.Model.Object.OTN (OTN)"
    , "import safe MtgPure.Model.Object.ToObjectN.Classes ("
    , forDeps \case
        ToObject x -> case x == 1 && n > 1 of
          True -> ""
          False -> "  ToObject" ++ show x ++ "(..),"
    , "  )"
    , m_to_n_pairs \x y -> do
        if
          | x == y -> ""
          | x == m && y == n -> ""
          | x < m || y <= n -> "import safe MtgPure.Model.Object.ToObjectN.Instances.ToObject_" ++ show x ++ "_" ++ show y ++ " ()"
          | otherwise -> ""
    , ""
    , if
        | length deps > 1 -> "type ON = ObjectN"
        | otherwise -> ""
    , if
        | length deps <= 1 -> ""
        | otherwise -> forDeps \case
            ToObject 1 -> ""
            ToObject x -> "to" ++ show x ++ " = toObject" ++ show x
    ]
 where
  forDeps f = unlines $ map f deps
  m_to_n_pairs f = unlines $ filter (not . null) $ map (uncurry f) $ nubOrd do
    x <- [m .. n]
    y <- [x .. n]
    pure (x, y)

useDebugLimit :: Bool
useDebugLimit = False

limit :: Int
limit = case useDebugLimit of
  True -> 4
  False -> 1 + fromEnum (maxBound :: OT)

newtype Sym = Sym Int
  deriving (Eq, Ord, Show)

data SymDesc
  = SymObjectN [Char]
  | SymObject
  deriving (Eq, Ord, Show)

interpretSym :: SymDesc -> Sym -> String
interpretSym desc (Sym n) = case desc of
  SymObjectN os -> [os !! n]
  SymObject -> [['a' ..] !! n]

allSyms :: [Sym]
allSyms = case useDebugLimit of
  True -> map Sym [0 .. limit - 1]
  False -> map Sym [0 .. fromEnum (maxBound :: OT)]

objectTypeDescs :: [SymDesc]
objectTypeDescs =
  map SymObjectN $
    filter p $
      map
        (`take` objectTypes)
        [0 .. limit]
 where
  p xs = not (null xs) && length xs <= limit

objectTypes :: [Char]
objectTypes = map f [minBound :: OT .. maxBound]
 where
  f o = ['A' ..] !! fromEnum o

-- https://stackoverflow.com/a/3100764
nubOrd :: (Ord a) => [a] -> [a]
nubOrd = go Set.empty
 where
  go s (x : xs)
    | x `Set.member` s = go s xs
    | otherwise = x : go (Set.insert x s) xs
  go _ _ = []

mainCodeGenToObjectN :: IO ()
mainCodeGenToObjectN = do
  let commonDir = srcDir ++ "/MtgPure/Model/Object/ToObjectN"
  let instancesHs = commonDir ++ "/Instances.hs"
  let instancesDir = commonDir ++ "/Instances"
  hsPaths' <- T.for objectTypeDescs \desc -> do
    let letters = case desc of
          SymObjectN os -> os
          SymObject -> error "should be passed SymObjectN instead"
    hsPaths1 <- T.for (getNIndices desc) \n ->
      if
        | length letters > n -> pure ""
        | otherwise -> do
            let results = objectToObjectNs desc n
            let hsPath :: FilePath = instancesDir ++ "/ToObject_" ++ show n ++ ".hs"
            withFile hsPath WriteMode \h -> do
              hPutStrLn h $ mkInstancesHeaderN n
              hPutStrLn h $ unlines results
              hFlush h -- needed?
            runFourmolu hsPath
            pure hsPath
    hsPaths2 <- T.for (getMNIndexPairs desc) \(m, n) ->
      if
        | length letters > n -> pure ""
        | otherwise -> do
            let zippedResults = objectMsToObjectN desc m n
            let (results, deps') = unzip zippedResults
            let deps = nubOrd $ concat deps'
            let hsPath :: FilePath = instancesDir ++ "/ToObject_" ++ show m ++ "_" ++ show n ++ ".hs"
            withFile hsPath WriteMode \h -> do
              print (m, n)
              hPutStrLn h $ mkInstancesHeaderMN deps m n
              hPutStrLn h $ unlines results
              hFlush h -- needed?
            runFourmolu hsPath
            pure hsPath
    pure $ hsPaths1 ++ hsPaths2
  let hsPaths = concatMap (filter (not . null)) hsPaths'
  withFile instancesHs WriteMode \h -> do
    let importPaths = map filePathToImport hsPaths
    hPutStrLn h $ mkInstancesHeader importPaths
    hFlush h -- needed?
  runFourmolu instancesHs

-- example: Foo\Bar/ToObject.hs becomes Foo.Bar.ToObject
filePathToImport :: FilePath -> String
filePathToImport = dropExtension . drop (length srcDir + 1) . go
 where
  go = \case
    [] -> []
    '/' : xs -> '.' : go xs
    '\\' : xs -> '.' : go xs
    x : xs -> x : go xs

----------------------------------------

objectToObjectNs :: SymDesc -> Int -> [String]
objectToObjectNs desc n = nubOrd do
  generateObjectsToObjectN (if False then desc else SymObject) n

getNIndices :: SymDesc -> [Int]
getNIndices desc = case desc of
  SymObjectN syms -> [1 .. length syms]
  SymObject -> error "should be passed SymObjectN instead"

generateObjectsToObjectN :: SymDesc -> Int -> [String]
generateObjectsToObjectN desc n = do
  sym <- symsN
  catMaybes [generateObjectToObjectN desc sym symsN]
 where
  symsN = take n allSyms

generateObjectToObjectN :: SymDesc -> Sym -> [Sym] -> Maybe String
generateObjectToObjectN desc sym symN =
  if
    | n < 1 -> Nothing
    | otherwise -> Just $ instanceLine ++ "\n  " ++ funcLine ++ "\n"
 where
  n = length symN

  instanceLine =
    unwords $
      ["instance", "Inst" ++ show n, "IsObjectType"]
        ++ map (interpretSym desc) symN
        ++ ["=>", "ToObject" ++ show n ++ "'", interpretSym desc sym]
        ++ map (interpretSym desc) symN
        ++ ["where"]

  funcLine =
    unwords
      [ "toObject" ++ show n ++ "'"
      , "="
      , "O" ++ if n == 1 then "1" else show n ++ interpretSym SymObject sym
      ]

----------------------------------------

newtype Dependency
  = ToObject Int
  deriving (Eq, Ord, Show)

objectMsToObjectN :: SymDesc -> Int -> Int -> [(String, [Dependency])]
objectMsToObjectN desc m n = nubOrd do
  generateObjectMsToObjectN (if False then desc else SymObject) m n

getMNIndexPairs :: SymDesc -> [(Int, Int)]
getMNIndexPairs desc = sortBy cmp $ nubOrd do
  m <- [1 .. lim]
  n <- [m .. lim]
  pure (m, n)
 where
  lim = case desc of
    SymObjectN syms -> length syms
    SymObject -> error "should be passed SymObjectN instead"
  cmp (a, b) (x, y) = compare (b, a) (y, x)

generateObjectMsToObjectN :: SymDesc -> Int -> Int -> [(String, [Dependency])]
generateObjectMsToObjectN desc m n = reverse do
  symsM <- symsMs
  catMaybes [generateObjectMToObjectN desc symsM symsN]
 where
  symsN = take n allSyms
  subSeqs = subsequences symsN
  symsMs = filter (\xs -> length xs == m) subSeqs

generateObjectMToObjectN :: SymDesc -> [Sym] -> [Sym] -> Maybe (String, [Dependency])
generateObjectMToObjectN desc symsM symsN =
  if
    | m == n ->
        Just
          ( instanceLine ++ "\n  toObject" ++ show n ++ " = id\n"
          , [ToObject n]
          )
    | n <= 1 ->
        Nothing
    | m < 1 ->
        Nothing
    | m + 1 == n ->
        Just
          ( instanceLine
              ++ "\n  toObject"
              ++ show n
              ++ " = ON"
              ++ show n
              ++ letterMissing
              ++ "\n"
          , [ToObject n]
          )
    | otherwise ->
        Just
          ( instanceLine
              ++ "\n  toObject"
              ++ show n
              ++ " x = "
              ++ telescope
              ++ "\n"
          , map ToObject [m + 1 .. n]
          )
 where
  m = length symsM
  n = length symsN
  letterMissing = case symsN \\ symsM of
    [x] -> interpretSym SymObject x
    _ -> error "impossible"
  seqSymsM = commas $ map (interpretSym desc) symsM
  telescope = telescopeToObjectN desc "x" symsM symsN
  instanceLine =
    unwords $
      ["instance", "Inst" ++ show n, "IsObjectType"]
        ++ map (interpretSym desc) symsN
        ++ ["=>", "ToObject" ++ show n, "(OTN '[" ++ seqSymsM ++ "])"]
        ++ map (interpretSym desc) symsN
        ++ ["where"]

telescopeToObjectN :: SymDesc -> String -> [Sym] -> [Sym] -> String
telescopeToObjectN desc acc symsM symsN = case m < n of
  True -> telescopeToObjectN desc acc' symsSucc symsN
  False -> acc
 where
  m = length symsM
  n = length symsN
  toObjectSucc = "to" ++ show (m + 1)
  newSym = head $ symsN \\ symsM
  symsSucc = sort $ newSym : symsM
  typeSucc =
    "(ON (OTN '[" ++ commas (map (interpretSym desc) symsSucc) ++ "]))"
  acc' = "(" ++ toObjectSucc ++ " " ++ acc ++ " :: " ++ typeSucc ++ ")"

commas :: [String] -> String
commas = intercalate ", "
